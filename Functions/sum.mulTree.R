##########################
#Summarise MCMCglmm data generated by mulTree function 
##########################
#Creates a table containing the modes and the credibility intervals for the fixed and the random terms
#v0.1
##########################
#SYNTAX :
#<mulTree.mcmc> a mcmc chain written by the mulTree function. Can be either a unique file or a chain name referring to multiple files. Use read.mulTree() to properly load the chains
#<CI> the credibility interval (can be more than one value)
#<...> any optional arguments to be passed to the hdr function
#
#Note,
#One might want to use all.modes=TRUE option for reporting all the modes using the hdr function. By default, hdr only calculates one mode.
##########################
#----
#guillert(at)tcd.ie - 12/08/2014
##########################
#Requirements:
#-R 3
#-R package "hdrcde"
#-R package "MCMCglmm"
#-R package "coda"
##########################


sum.mulTree<-function(mulTree.mcmc, CI=95, ...)
{   #stop("IN DEVELOPEMENT")
    #warning("only works with uni-modal and hdr")
#HEADER
    require(hdrcde)
    require(MCMCglmm)

#DATA
    #mulTree.mcmc
    if (class(mulTree.mcmc) == "MCMCglmm") {
        #mulTree.mcmc is a single "MCMCglmm" object
        chain=FALSE
    } else {
        #is mulTree.mcmc a list?
        if (class(mulTree.mcmc) == "list") {
            #does the list contain only "MCMCglmm" objects
            if (all(summary(mulTree.mcmc)[,2] == "MCMCglmm")) {
                chain=TRUE
            } else {
                stop("Input is not a \"MCMCglmm\" object of list.", call.=FALSE)
            }
        } else {
            stop("Input is not a \"MCMCglmm\" object of list.", call.=FALSE)
        }
    }

    #CI
    if (class(CI) != 'numeric') {
        stop("Credibility interval must be between 0 and 100.", call.=FALSE)
    }
    if (any(CI < 0)) {
        stop("Credibility interval must be between 0 and 100.", call.=FALSE)
    } else {
        if (any(CI > 100)) {
            stop("Credibility interval must be between 0 and 100.", call.=FALSE)
        }
    }

#FUNCTIONS

    FUN.table.mcmc<-function(data.mcmc) {
        if(class(data.mcmc) == "MCMCglmm") {
            #Isolates the fixed terms (model$Sol) and the random terms (model$VCV)
            #Adding the fixed terms
            table.mcmc<-as.data.frame(data.mcmc$Sol)
            #Adding the random terms
            random.terms<-c("phylogenetic.variance","residual.variance")
            table.mcmc[random.terms[1]]<-as.vector(data.mcmc$VCV[,1])
            table.mcmc[random.terms[2]]<-as.vector(data.mcmc$VCV[,2])
        } else {
            table.mcmc<-as.data.frame(data.mcmc[[1]]$Sol)
            random.terms<-c("phylogenetic.variance","residual.variance")
            table.mcmc[random.terms[1]]<-as.vector(data.mcmc[[1]]$VCV[,1])
            table.mcmc[random.terms[2]]<-as.vector(data.mcmc[[1]]$VCV[,2])
            for (n in 2:length(data.mcmc)) {
                table.mcmc.bis<-as.data.frame(data.mcmc[[n]]$Sol)
                table.mcmc.bis[random.terms[1]]<-as.vector(data.mcmc[[n]]$VCV[,1])
                table.mcmc.bis[random.terms[2]]<-as.vector(data.mcmc[[n]]$VCV[,2])
                table.mcmc<-rbind(table.mcmc, table.mcmc.bis)
            }
        }
        #Output
        return(table.mcmc)
    }

    FUN.hdr.mcmc<-function(table.mcmc, CI, ...) {
        #A list calculating the hdr for each fix and random terms
        hdr.mcmc<-lapply(as.list(table.mcmc), hdr, CI, ...)
        #Output
        return(hdr.mcmc)
    }

    FUN.sum.mcmc<-function(hdr.mcmc) {
        #Summarize the hdr.mcmc list building a table with the terms as rows and the estimates and the CI as columns
        #Preparing the columns
        terms<-names(hdr.mcmc)
        estimates<-rep(NA, length(terms)) ; lower.CI<-rep(NA, length(terms)) ; upper.CI<-rep(NA, length(terms))
        #Filling the columns
        for (n in 1:length(terms)) {
            estimates[n]<-hdr.mcmc[[n]]$mode
            lower.CI[n]<-min(hdr.mcmc[[n]]$hdr)
            upper.CI[n]<-max(hdr.mcmc[[n]]$hdr)
        }
        #Creating the data.frame
        sum.mcmc<-data.frame(row.names=terms, estimates=estimates, lower.CI=lower.CI, upper.CI=upper.CI)
        #Output
        return(sum.mcmc)
    }

#SUMMARIZYNG THE MCMC
    
    table<-FUN.sum.mcmc(FUN.hdr.mcmc(FUN.table.mcmc(mulTree.mcmc), CI, ...))

#OUPTUT

    return(table)

#End
}

#example
sum.mulTree.example=FALSE
if(sum.mulTree.example == TRUE) {
    #CREATING THE FILES
    data_table<-data.frame(taxa=LETTERS[1:5], var1=rnorm(5), var2=c(rep('a',2), rep('b',3)))
    trees_list<-list() ; for (i in 1:2) {trees_list[[i]]<-rcoal(5, tip.label=LETTERS[1:5])} ; class(trees_list)<-'multiPhylo'
    mulTree_data<-as.mulTree(data_table, trees_list, species="taxa")
    form=var1~var2
    param=c(10000, 100, 250)
    prior<-list(R = list(V = 1/2, nu=0.002), G = list(G1=list(V = 1/2, nu=0.002)))
    mulTree(mulTree_data, form, param, priors=prior, verbose=FALSE, output="mulTree.ex", warn=FALSE)

    #Reading all the chains for both trees
    all_chains<-read.mulTree("mulTree.ex")
    sum.mulTree(all_chains) #Use sum.mulTree to properly summarize the data!

    #Remove the generated files from the current directory
    file.remove(list.files(pattern="mulTree.ex"))
    #TRUE TRUE TRUE TRUE TRUE TRUE
}